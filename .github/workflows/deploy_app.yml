  name: üöÄ Deploy FastAPI App on AWS EC2

  on:
    workflow_dispatch:

  env:
    AWS_REGION: 'us-east-1'

  jobs:
    deploy:
      runs-on: ubuntu-latest

      steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create a unique EC2 key pair
        id: create_keypair
        run: |
          set -eo pipefail  # Fail on any error in the pipeline
          KEY_NAME="fastapi-key-$(date +%s)"
          KEY_FILE="${KEY_NAME}.pem"

          echo "Creating key pair: $KEY_NAME..."
          KEY_MATERIAL=$(aws ec2 create-key-pair \
            --key-name "$KEY_NAME" \
            --query 'KeyMaterial' \
            --output text \
            --region ${{ env.AWS_REGION }}  # Explicitly use the region
          )

          # Write key material to file atomically
          echo "$KEY_MATERIAL" > "$KEY_FILE.tmp"
          mv "$KEY_FILE.tmp" "$KEY_FILE"  # Atomic rename to avoid partial writes
          chmod 400 "$KEY_FILE"

          # Verify the key was written
          if [ ! -s "$KEY_FILE" ]; then
            echo "‚ùå Error: Key file is empty!"
            exit 1
          fi

          # Set outputs for later steps
          echo "key_name=$KEY_NAME" >> $GITHUB_OUTPUT
          echo "key_file=$KEY_FILE" >> $GITHUB_OUTPUT

          echo "‚úÖ Key pair created: $KEY_NAME ($KEY_FILE)"

      - name: Lookup VPC/Subnet/SG dynamically
        run: |
          VPC_ID=$(aws ec2 describe-vpcs --query 'Vpcs[0].VpcId' --output text)
          echo "VPC_ID=$VPC_ID" >> $GITHUB_ENV

          SUBNET_ID=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$VPC_ID" --query 'Subnets[0].SubnetId' --output text)
          echo "SUBNET_ID=$SUBNET_ID" >> $GITHUB_ENV

          SG_ID=$(aws ec2 describe-security-groups --filters "Name=vpc-id,Values=$VPC_ID" --query 'SecurityGroups[0].GroupId' --output text)
          echo "SG_ID=$SG_ID" >> $GITHUB_ENV

      - name: Update Security Group to allow SSH and HTTP
        run: |
          echo "Authorizing inbound SSH (port 22) and HTTP (port 8000) traffic on SG ${{ env.SG_ID }}"

          aws ec2 authorize-security-group-ingress \
            --group-id ${{ env.SG_ID }} \
            --protocol tcp \
            --port 22 \
            --cidr 0.0.0.0/0 || echo "Rule for SSH already exists"

          aws ec2 authorize-security-group-ingress \
            --group-id ${{ env.SG_ID }} \
            --protocol tcp \
            --port 8000 \
            --cidr 0.0.0.0/0 || echo "Rule for HTTP already exists"


      - name: Launch EC2 Instance with new key pair
        id: ec2
        run: |
          INSTANCE_ID=$(aws ec2 run-instances \
            --image-id ami-0c02fb55956c7d316 \
            --instance-type t2.micro \
            --key-name ${{ steps.create_keypair.outputs.key_name }} \
            --subnet-id ${{ env.SUBNET_ID }} \
            --security-group-ids ${{ env.SG_ID }} \
            --associate-public-ip-address \
            --query 'Instances[0].InstanceId' --output text)

          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV

          aws ec2 wait instance-running --instance-ids $INSTANCE_ID

          PUBLIC_IP=$(aws ec2 describe-instances \
            --instance-ids $INSTANCE_ID \
            --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)

          echo "EC2_PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV

      - name: Wait for SSH to Become Available
        run: sleep 60

      # - name: Install FastAPI & Start App
      #   run: |
      #     chmod 400 ${{ steps.create_keypair.outputs.key_file }}
          
      #     ssh -o StrictHostKeyChecking=no -i ${{ steps.create_keypair.outputs.key_file }} ec2-user@${{ env.EC2_PUBLIC_IP }} << EOF
      #     set -e

      #     sudo yum update -y
      #     sudo yum install -y git python3 python3-venv

      #     python3 -m venv /home/ec2-user/venv
      #     source /home/ec2-user/venv/bin/activate

      #     if [ ! -d "/home/ec2-user/customer-app" ]; then
      #       git clone https://github.com/${{ github.repository }} /home/ec2-user/customer-app
      #     else
      #       cd /home/ec2-user/customer-app
      #       git pull
      #     fi

      #     cd /home/ec2-user/customer-app || { echo "Failed to cd into customer-app"; exit 1; }
      #     ls -l

      #     pip install --upgrade pip
      #     pip install -r requirements.txt || { echo "Failed to install requirements"; exit 1; }

      #     cat > /home/ec2-user/customer-app/.env << ENV_EOF
      #     DB_HOST=${{ secrets.DB_HOST }}
      #     DB_USER=${{ secrets.DB_USERNAME }}
      #     DB_PASSWORD=${{ secrets.DB_PASSWORD }}
      #     DB_NAME=${{ secrets.DB_NAME }}
      #     DB_PORT=3306
      #     ENV_EOF

      #     chmod 600 /home/ec2-user/customer-app/.env

      #     pkill -f "uvicorn backend:app" || true

      #     nohup /home/ec2-user/venv/bin/uvicorn backend:app --app-dir /home/ec2-user/customer-app --host 0.0.0.0 --port 8000 > /home/ec2-user/uvicorn.log 2>&1 &
      #     EOF

      # 

      - name: Install Dependencies & Configure Nginx
        run: |
          chmod 400 ${{ steps.create_keypair.outputs.key_file }}
          
          ssh -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=/dev/null \
              -i ${{ steps.create_keypair.outputs.key_file }} \
              ec2-user@${{ env.EC2_PUBLIC_IP }} << 'EOF'
          set -e
          exec > >(tee /home/ec2-user/deploy.log) 2>&1

          echo "=== Starting Deployment ==="
          
          # System updates and dependencies
          sudo yum update -y
          sudo yum install -y git python3 python3-venv nginx mysql

          # Python environment setup
          python3 -m venv /home/ec2-user/venv || echo "venv exists"
          source /home/ec2-user/venv/bin/activate

          # Install MySQL client libraries
          sudo yum install -y mysql-devel
          pip install mysql-connector-python

          # Application setup
          if [ ! -d "/home/ec2-user/app" ]; then
            git clone https://github.com/${{ github.repository }} /home/ec2-user/app
          else
            cd /home/ec2-user/app && git pull
          fi

          cd /home/ec2-user/app
          pip install --upgrade pip
          pip install -r requirements.txt

          # Create environment file with DB credentials
          cat > /home/ec2-user/app/.env << 'ENV_EOF'
          DB_HOST=${{ secrets.DB_HOST }}
          DB_USERNAME=${{ secrets.DB_USERNAME }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_NAME=${{ secrets.DB_NAME }}
          DB_PORT=3306
          ENV_EOF

          # Configure Nginx
          sudo mkdir -p /etc/nginx/conf.d
          sudo tee /etc/nginx/conf.d/fastapi.conf > /dev/null << 'NGINX_EOF'
          server {
              listen 80;
              server_name _;
              
              location / {
                  proxy_pass http://127.0.0.1:8000;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
              }
          }
          NGINX_EOF

          # Validate and start Nginx
          sudo nginx -t
          sudo systemctl enable --now nginx

          # Stop existing Uvicorn if running
          pkill -f "uvicorn backend:app" || true
          sleep 2

          # Start Uvicorn (bound to localhost only)
          nohup /home/ec2-user/venv/bin/uvicorn backend:app \
            --app-dir /home/ec2-user/app \
            --host 127.0.0.1 \
            --port 8000 \
            > /home/ec2-user/uvicorn.log 2>&1 &

          echo "=== Deployment Complete ==="
          echo "Access your app at: http://${{ env.EC2_PUBLIC_IP }}"
          EOF



      - name: Show Public URL
        run: |
          echo "‚úÖ Your FastAPI app is deployed and running!"
          echo "üåê Open the app here: http://${{ env.EC2_PUBLIC_IP }}:8000"
